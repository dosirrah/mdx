#!/usr/bin/env python

# mdx.py: Markdown preprocessor for numbered references.
# Repository: https://github.com/dosirrah/mdx

import re
import argparse
import os
import sys

class UndefinedReferenceError(KeyError):
    """Custom exception for undefined references in the Markdown file."""
    pass

def process_references(input_file):
    """
    Parses a .mdx Markdown file with @label definitions and #label references.
    Preserves spacing for markdown tables and fixed-width text.
    Outputs a clean .md file.
    """
    base_name, ext = os.path.splitext(input_file)
    if ext.lower() != ".mdx":
        raise ValueError("Error: Input file must have a .mdx extension.")

    output_file = f"{base_name}.md"

    with open(input_file, "r", encoding="utf-8") as file:
        lines = file.readlines()

    label_map = {}  # Stores {label: number}
    group_counters = {}  # Stores counters for named groups
    global_counter = 1  # Default global numbering
    missing_references = []  # Track undefined references

    updated_lines = []
    
    # Step 1: Assign numbers to labeled elements
    for line_num, line in enumerate(lines, start=1):
    
        # Detect if we're inside a table row (line starts and ends with | and contains non-whitespace characters)
        inside_table = re.match(r"^\s*\|.*\S.*\|\s*$", line) is not None
    
        # Replace all named enumeration labels (e.g., @prob:one → 1)
        def replace_named_label(match):
            nonlocal group_counters
            group, label = match.groups()
            label_key = f"{group}:{label}"
    
            if label_key not in label_map:
                if group not in group_counters:
                    group_counters[group] = 1
                label_map[label_key] = str(group_counters[group])
                group_counters[group] += 1
    
            label_number = label_map[label_key]
            return label_number.ljust(len(match.group(0))) if inside_table else label_number
    
        line = re.sub(r"@([a-zA-Z0-9_]+):([a-zA-Z0-9_]+)", replace_named_label, line)
    
        # Replace all global enumeration labels (e.g., @label → 1)
        def replace_global_label(match):
            nonlocal global_counter
            label = match.group(1)

            if label not in label_map:
                label_map[label] = str(global_counter)
                global_counter += 1
    
            label_number = label_map[label]
            return label_number.ljust(len(match.group(0))) if inside_table else label_number
    
        line = re.sub(r"@([a-zA-Z0-9_]+)", replace_global_label, line)
    
        updated_lines.append(line)
    
    # Step 2: Replace references and preserve table alignment
    final_lines = []
    #inside_table = False  # Track whether we're inside a Markdown table

    for line_num, line in enumerate(updated_lines, start=1):

        # Detect if we're inside a Markdown table row
        inside_table = re.match(r"^\s*\|.*\S.*\|\s*$", line) is not None
    
        # Function to replace references while preserving table formatting
        def replace_reference(match):
            group, label, global_label = match.groups()
            
            # Determine the correct reference key (named or global)
            if group and label:
                ref_key = f"{group}:{label}"
            else:
                ref_key = global_label
    
            # Check if reference exists
            if ref_key in label_map:
                replacement = label_map[ref_key]
            else:
                print(f"Warning: Undefined reference '{ref_key}' on line {line_num}", file=sys.stderr)
                missing_references.append((line_num, ref_key))
                return match.group(0)  # Keep the original reference if it's undefined
    
            # Preserve alignment in tables
            if inside_table:
                return replacement.ljust(len(match.group(0)))
            return replacement
    
        # Replace all references in the line
        line = re.sub(r"(?<!^)#(\w+):(\w+)|(?<!^)#(\w+)", replace_reference, line)
    
        final_lines.append(line)

    # If there are undefined references, raise a custom exception at the end
    if missing_references:
        error_message = f"\nSummary: {len(missing_references)} undefined references found!\n"
        for line_num, label in missing_references:
            error_message += f"  - Undefined reference '{label}' on line {line_num}\n"
        raise UndefinedReferenceError(error_message)

    # Insert a comment at the top of the file
    final_lines.insert(0, f"<!-- Generated by mdx.py from {input_file}. You can obtain mdx.py from https://github.com/dosirrah/mdx -->\n")

    # Write processed content to new .md file
    with open(output_file, "w", encoding="utf-8") as file:
        file.writelines(final_lines)

    print(f"Processed file saved as: {output_file}")

def main():
    """Handles command-line arguments and runs the reference processor."""
    parser = argparse.ArgumentParser(description="Process .mdx Markdown references and numbering.")
    parser.add_argument("input_file", help="Path to the .mdx file.")

    args = parser.parse_args()

    try:
        process_references(args.input_file)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except UndefinedReferenceError as e:
        print(f"Reference Error:\n{e}", file=sys.stderr)
        sys.exit(2)

if __name__ == "__main__":
    main()

